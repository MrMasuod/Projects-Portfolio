#include "Acceleo.h"

Acceleo::Acceleo()
{
    char data[] = "YYYY:MM:DDTHH:MM:SSZ";
    writeFile(data);
}

int checkAlert = 0;
bool append = false;
float AbsoluteVal(float testval) {
    // Check if the value is negative
    if (testval < 0) {
        testval = -testval; // If negative, make it positive by negating it
    }
    return testval;
}

void Acceleo :: acceloReading(char msg[])
{

char x[4];
char y[4];
char z[4];

x[0]=msg[3]; x[1] = msg[4]; x[2]=msg[5]; x[3]= '\0';
y[0]=msg[6]; y[1] = msg[7]; y[2]=msg[8]; y[3]= '\0';
z[0]=msg[9]; z[1] = msg[10]; z[2]=msg[11]; z[3]= '\0';

cout<<"X Data "<< x <<endl;
cout<<"Y Data "<< y <<endl;
cout<<"Z Data "<< z <<endl;

int sigx = SignedVal(x);
int sigy = SignedVal(y);
int sigz = SignedVal(z);

/*
int fX = acceleroCalculation(X);
int fY = acceleroCalculation(Y);
int fZ = acceleroCalculation(Z);
*/

float FinalAcc_X = (float)sigx/64;
float FinalAcc_Y = (float)sigy/64;
float FinalAcc_Z = (float)sigz/64;

if (FinalAcc_X > maxX) {
    maxX = FinalAcc_X;
}
if (FinalAcc_Y > maxY) {
    maxY = FinalAcc_Y;
}
if (FinalAcc_Z > maxZ) {
    maxZ = FinalAcc_Z;
}

if (Z_offset == true){
    FinalAcc_Z = FinalAcc_Z - 1;
}

cout<<"Final Accelerometer Value X ="<<FinalAcc_X<<" Y ="<<FinalAcc_Y<< " Z =" <<FinalAcc_Z<<endl;

char accelerometerReadingValue[25];
if(AbsoluteVal(FinalAcc_Y) > 0.2) {
    checkAlert = checkAlert + 1;
} else {
     checkAlert = 0;
}

if(checkAlert > 2){
    append = true;
    total_alert_value = total_alert_value + 1;
    combineFloatsToString(FinalAcc_X, FinalAcc_Y, FinalAcc_Z, append, accelerometerReadingValue);
}
else{
    append = false;
    combineFloatsToString(FinalAcc_X, FinalAcc_Y, FinalAcc_Z, append,  accelerometerReadingValue);
}

//writeFile("YYYY:MM:DDTHH:MM:SSZ");
writeFile(accelerometerReadingValue);

}


void Acceleo :: setZoffset(bool offset)
{
    Z_offset+= offset;
}

void Acceleo :: writeFile(char accleoValToWrite[])
{
    const char* appendStr = accleoValToWrite;

    FILE* file;
    char line[256];
    long lastNonEmptyLinePos = -1;
    long currentPosition;

    // Open the file for reading
    file = fopen("output.txt", "r");

    // Check if the file was opened successfully
    if (file == NULL) {
        printf("Error opening the file for reading!\n");
    }

    // Find the position of the last non-empty line
    while (fgets(line, sizeof(line), file) != NULL) {
        currentPosition = ftell(file);
        if (line[0] != '\0' && line[0] != '\n') {
            lastNonEmptyLinePos = currentPosition;
        }
    }
    // Close the file
    fclose(file);

    // Open the file for appending
    file = fopen("output.txt", "a");

    // Check if the file was opened successfully
    if (file == NULL) {
        printf("Error opening the file for appending!\n");
    }

    // Move to the position after the last non-empty line
    fseek(file, lastNonEmptyLinePos, SEEK_SET);

    // Append the string after the last non-empty line
    fprintf(file, "\n%s", appendStr);

    // Close the file
    fclose(file);
}

void Acceleo :: combineFloatsToString(float value1, float value2, float value3, bool alert, char* result) {
    // Format the three float values into a single string
    if(alert == true){
        total_alert_value = total_alert_value + 1;
        snprintf(result, 50, "X= %.2f Y= %f Z= %f [ALERT]", value1, value2, value3);
    }
    else{
        snprintf(result, 50, "X= %.2f Y= %f Z= %f", value1, value2, value3);
    }  
}

unsigned int Acceleo :: SignedVal(char hexValue[3]) {
    // Convert the hexadecimal string to an integer
    int intValue = 0;
    for (int i = 0; i < 3; ++i) {
        intValue <<= 4; // Shift previous bits to the left by 4
        char c = hexValue[i];
        if (c >= '0' && c <= '9') {
            intValue += c - '0';
        } else if (c >= 'A' && c <= 'F') {
            intValue += 10 + (c - 'A');
        } else if (c >= 'a' && c <= 'f') {
            intValue += 10 + (c - 'a');
        } else {
            return -1; // Error code for invalid input
        }
    }
    // Handle the 12-bit 2's complement representation
    int decimalValue;
    if (intValue & 0x800) { // Check the 12th bit (MSB) for sign
        intValue |= 0xF000; // Sign extend the value for negative numbers
        decimalValue = -((~intValue & 0xFFF) + 1); // Calculate 2's complement for negative numbers
    } else {
        decimalValue = intValue & 0xFFF; // Positive number, extract the value
    }
    std::cout << "Decimal representation: " << decimalValue << std::endl;
    return decimalValue;
}


int Acceleo ::  checksum(char checksumval[13]) {

    int sum = 0;
    for (int i = 0; i < 12 && checksumval[i] != '\0'; ++i) {
        int asciiValue = static_cast<int>(static_cast<unsigned char>(checksumval[i])); // Get ASCII value of each character
        std::cout << "Character: " << checksumval[i] << " ASCII Decimal Value: " << asciiValue << std::endl;
        sum += asciiValue; // Adding ASCII value of each character
    }
    // Take modulo 255 to keep it within the range
    while(sum > 256){
        sum = sum - 256;
    }
    std::cout << "Result after summing and modulo 255 in hexadecimal: " << sum << std::endl;
    // Convert the hexadecimal string to an integer
    int intValue = 0;
    for (int i = 12; i < 14; ++i) {
        char c = checksumval[i];
        std::cout << "Character: " << c << std::endl;
        if (c >= '0' && c <= '9') {
            intValue += c - '0';
        } else if (c >= 'A' && c <= 'F') {
            intValue += 10 + (c - 'A');
        } else if (c >= 'a' && c <= 'f') {
            intValue += 10 + (c - 'a');
        } else {
            return -1; // Error code for invalid input
        }
        if(i == 12){
            intValue = intValue *16;
        }
    }
    std::cout << "Result after converting Checksum to decimal: " << intValue << std::endl;
    if(intValue == sum) {
        std::cout << "Checksum Valid ! " << std::endl;
        total_Accelerometer_value = total_Accelerometer_value + 1;
    } else {
        total_Nonvalid_checksum = total_Nonvalid_checksum + 1;
    }
    return 0;
}

void Acceleo ::  initialization() {
    
    total_Nonvalid_checksum = 0;
    total_Accelerometer_value = 0;
    total_alert_value = 0;
    maxX = 0;
    maxY = 0;
    maxZ = 0;
}